---
title: "Preliminary Analysis of NanoString Data"
author: "christiane morecock"
date: "2022-12-04"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

# Read in Libraries
library(dplyr)
library(janitor)
library("DESeq2")
library("ComplexHeatmap")
library("NMF")
library(RNASeqBits)
library(ggplot2)
library(ggrepel)
library(tidyverse)
library(viridis)
library(DT)
library(plotly)
library(WGCNA)
library(heatmaply)
library(textshape)
library(gplots)
library(MASS)


```



## Samples 
Information about sample names
```{r metadata, echo=FALSE, warning=FALSE, message=FALSE}
input_dir <- "./threshold1_22/"

# Load Previously Transformed data Data
load("./threshold1_22/wgcna/clean_expr_clin_dat.RData")
## log2_norm = log2(Normalized Data +1)
## log2_normA for timepoint A
## log2_normB for timepoint B
## a_bvars = blood cell variables with A and B timepoints
## Clin_scoreVars = clinical scoring variables with A and B timepoints
## engraftment_vars = engraftment datapoints, rownames are patient IDs

load("./raw_data_transfigurations.RData")
## Description in RealignToProject2023.Rmd

# saving normalized data configurations to a variable
vnames <- load(str_c(input_dir, "normalized_data_configurations.RData"))
## Same as raw data transfigurations, just with norm data. 
# TODO: standardize scripts for both of data files and standarize names 

# List of candidate housekeeping genes
candidates <- read_csv("./threshold1_22/NormFinder_OrderedResults_threshold1_222022-10-10.csv")
# List of official housekeeping genes 
housekeeping <- read.csv(str_c(input_dir, "housekeeping_genes.csv"))

# code to show metadata in table
df %>% 
  knitr::kable(
      col.names = (c("File Name", 
             "Sample",
             "Timepoint",
             "Cart")),
      align = "lccrr"
  ) 

```

## QC Analysis

There were no QC flags on the raw data. 


## Raw Data 

### Plot the Spike-in controls across samples

```{r spike_in, echo=FALSE, warning=FALSE, message=FALSE}
# add cartridge ID to metadata
trans_dat$cart <- df %>% pull(cart)
# plot spike in controls across samples, color for cartridge ID
trans_dat %>% 
  mutate(max_spike = osa_mi_r414 == max(osa_mi_r414),
         min_spike = osa_mi_r414 == min(osa_mi_r414),
         names = str_remove(names,"(a|b)"),
         names = toupper(names)) %>% 
  ggplot(aes(y= osa_mi_r414, x = fct_reorder(names, osa_mi_r414)))+
  geom_point(aes(color = cart))+
  gghighlight::gghighlight(max_spike ==TRUE |  min_spike == TRUE,
                           label_key = osa_mi_r414,
                           unhighlighted_params = list(colour = NULL) )+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  scale_colour_grey()+
  ggtitle("Spike-in Control across samples")+
  ylab("osa-mir414 Raw Counts")+
  xlab("Samples")


```


This shows a max of `r max(trans_dat$osa_mi_r414)`, min of `r min(trans_dat$osa_mi_r414)` and range of `r max(trans_dat$osa_mi_r414) - min(trans_dat$osa_mi_r414)`


## Selecting a threshold for normalization 

```{r threshold_calc, echo=FALSE}

means_vec <- means_vec[-1:-3]

mean_thresh <-  round(mean(means_vec), digits = 0)

# mean of mean + 1sd 
threshold1 <-  round(mean(means_vec) + sd(means_vec), digits = 0)
#threshold1
# mean of mean + 2sd 
threshold2 <-  round(mean(means_vec) + 2 * sd(means_vec), digits = 0)
#threshold2
# mean of mean + 3sd 
threshold3 <-  round(mean(means_vec) + 3 * sd(means_vec), digits = 0)
#threshold3
# mean of mean + 4sd 
threshold4 <-  round(mean(means_vec) + 4 * sd(means_vec), digits = 0)
#threshold4
```

```{r calculateRetainedData}
n_datapoints <- length(log_dat_long$raw_counts)

included <- log_dat_long %>% 
  filter(raw_counts > log2(threshold2)) %>% 
  pull(raw_counts) %>% 
  length()

```
Four thresholds were calculated for normalization. Below, the graph will show the thresholds plotted on the raw counts under 150

Mean of Mean of Negative Controls + 1 Standard Deviation = `r threshold1`  

Mean of Mean of Negative Controls + 2 Standard Deviation = `r threshold2`  

Mean of Mean of Negative Controls + 3 Standard Deviation = `r threshold3`  

Mean of Mean of Negative Controls + 4 Standard Deviation = `r threshold4`  

**For this Report we chose a Threshold of 22**

`r round(included/n_datapoints, 4) * 100` % of data points maintained by this threshold 



```{r all_raw_data, , echo=FALSE, warning=FALSE, message=FALSE}

# Point graph of thresholds and datapoints
point_graph_raw <- log_dat_long %>% 
  # filter(raw_counts < 150) %>% 
  ggplot(aes(x= probe_name, 
             y = raw_counts))+
  geom_jitter(color = "#949494",
              size = 1,
              alpha = 0.2) +
  # scale_color_viridis(discrete=TRUE)+
  geom_hline(yintercept = log2(threshold1),
             # color ="#99CCED",
             size = 1,
             alpha = 1) +
  theme_classic()+
    # scale_y_continuous(name = "Raw Counts", breaks = seq(0, 150, 10), limits = c(0,150))+
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank())+
  scale_colour_grey()+
  xlab("Probes")+
  ylab("log2(raw counts)")

point_graph_raw


```

```{r all_raw_density, , echo=FALSE, warning=FALSE, message=FALSE}
# Density plot of thresholds and datapoints
density_threshold <- raw_dat_long %>% 
  mutate(group = str_to_title(group)) %>% 
  # filter(raw_counts < 150) %>%
  ggplot(aes( x = raw_counts,
             color = group))+
  geom_density(size = 1.25,
              alpha = 0.2) +
  scale_color_viridis(discrete=TRUE)+
  geom_vline(xintercept = threshold1,
             # color ="#99CCED",
             size = 1,
             alpha = 0.5) +
   scale_x_continuous(name = "Raw Counts", breaks = seq(0, 150, 10), limits = c(0,150))+
  theme_classic()+
  scale_colour_grey()

density_threshold

```

## PCA Raw data

```{r PCA_raw, echo=FALSE, warning=FALSE, message=FALSE}
# PCA plot before normalization
log2_raw <- log2_raw %>% 
  column_to_rownames("probe_name") %>% 
  dplyr::select(-accession_number, -annotation)

## PCA Analysis
data.scaled <- na.omit( as.data.frame(t(scale(t(as.matrix(log2_raw))))) )  ##also removes all rows that were assigned a value of 20 for all samples as these will have a NaN value.

pca <-  prcomp(t(data.scaled))

## The percent variance Explained:
# data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))]


PCAdata = data.frame(pca$x, samples, samples = samples$condition, stringsAsFactors = F)

PCA_before <- PCAdata %>% 
  as_data_frame() %>% 
  ggplot(aes(x = as.numeric(PC1), y = as.numeric(PC2), label = name)) +
  theme(plot.title = element_text(lineheight = 0.8, face="bold")) +
  ggtitle("PCA Analysis, raw intensities") +
  geom_point(aes(color = condition ), size = 3) +
  geom_text_repel(colour = "black", size = 3) +
  geom_hline(yintercept = 0, colour = "lightgrey", size=.1) +
  geom_vline(xintercept = 0, colour = "lightgrey", size=.1) +
  labs(color = "Condition") +
  theme_classic() +
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) +
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" ))+
  scale_color_grey()

PCA_before

```


## Normalization 
Normalization was done using the developed pipeline from the Bioinformatics Core. 

![Bei's pipeline](../nanostring/normalization_pipeline.png)

### Background Threshold

**The raw NanoString counts had threshold set to mean of mean of negative controls + 1SD of the negative control probes, then was exported from Nsolver to the NormFinder script where houseskeeping genes were identified.**
This background threshold of 20 had 22% to 66%  normalized reads above the threshold
Using background subtraction, 21% to 48% of normalized reads were above the threshold.  




### HouseKeeping Genes Selected 

NormFinder function in R was used to find the most stable genes across samples and timepoints to be used as housekeeping genes in normalization. I removed all genes where the mean count was less than 50, then I ran the NormFinder program. The following genes with a stability less than 0.25 were investigated for housekeeping genes. 



```{r normfinder_candidates, echo=FALSE, warning=FALSE, message=FALSE}
library(DT)

# Listof candidate Genes. Probably does not need to be displayed

candidates %>% 
  filter(Stability < 0.25) %>% 
  data.table::data.table()

```

Then, I used the minimum CV% + 20% to narrow down the list further. 

```{r normfinder_cv, echo=FALSE, warning=FALSE, message=FALSE}
# List of genes after CV% filter 
 ## Probably does not need displaying
housekeeping %>%
  data.table::data.table()

```





## Normalized Data

### PCA Normalized data

```{r norm_pca, echo=FALSE, warning=FALSE, message=FALSE}
### PCA after normalization

## PCA Analysis
data.scaled <- na.omit( as.data.frame(t(scale(t(as.matrix(log2_norm))))) )  ##also removes all rows that were assigned a value of 20 for all samples as these will have a NaN value.

pca <-  prcomp(t(data.scaled))

## The percent variance Explained:
# data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))]


PCA_after<- ggplot(data = data.frame(pca$x, samples, samples = samples$condition, stringsAsFactors = F), 
       aes(x = as.numeric(PC1), y = as.numeric(PC2), label = name)) +
  theme(plot.title = element_text(lineheight = 0.8, face="bold")) +
  ggtitle("PCA Analysis, after normalization") +
  geom_point(aes(color = condition), size = 3) +
  geom_text_repel(colour = "black", size = 3) +
  geom_hline(yintercept = 0, colour = "lightgrey", size=.1) +
  geom_vline(xintercept = 0, colour = "lightgrey", size=.1) +
  labs(color = "Condition") +
  theme_classic() +
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) +
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" )) +
  scale_color_grey()

PCA_after

```



```{r boxplot_norm, echo=FALSE, warning=FALSE, message=FALSE}

### Box Plot of Log2 Normalized Data
library(reshape2)

mtx_to_plot <- melt(log2_norm)
colnames(mtx_to_plot) <- c("Sample", "Exp")
#mtx_to_plot <- left_join(mtx_to_plot, annot)

# png(filename=paste("BoxPlot_log2_NormalizedCount_prelim.png", sep=""), width=800, height=800, res=300)

boxnorm <- mtx_to_plot %>% 
  mutate(Group = str_extract(Sample, "(A|B)")) %>% 
  filter(Exp > log2(threshold+1)) %>% 
  ggplot(aes(x = Sample, y = Exp, fill = Group))+
  geom_boxplot() +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.title.x = element_blank()) +
  scale_fill_grey()+
  ylab("log2-Expression")

ggplotly(boxnorm)


```


```{r spike_in_norm, echo=FALSE, warning=FALSE, message=FALSE}

### Display spike in controls across samples AFTER normalization
df %>%  
  full_join(trans_norm,
            by = c("sample" = "names"))  %>% 
  clean_names() %>% 
  mutate(max_spike = osa_mi_r414 == max(osa_mi_r414),
         min_spike = osa_mi_r414 == min(osa_mi_r414)) %>% 
  ggplot(aes(y= osa_mi_r414, x = fct_reorder(sample, osa_mi_r414)))+
  geom_point(aes(color = cart))+
  gghighlight::gghighlight(max_spike ==TRUE |  min_spike == TRUE,
                           label_key = osa_mi_r414,
                           unhighlighted_params = list(colour = NULL) )+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  scale_colour_grey()+
  ggtitle("Spike-in Control across samples AFTER Normalization")+
  ylab("osa-mir414 Raw Counts")+
  xlab("Samples")



```
This shows a max of `r max(trans_norm$osa_mi_r414)`, min of `r min(trans_norm$osa_mi_r414)` and range of `r max(trans_norm$osa_mi_r414) - min(trans_norm$osa_mi_r414)`



# Correlation  

```{r heatmap_corr, echo=FALSE, warning=FALSE, message=FALSE}

library(dendextend)
library(heatmaply)
library(tibble)
library(dynamicTreeCut)
suppressPackageStartupMessages(library(gplots))
# dendextend documentation: https://cran.r-project.org/web/packages/dendextend/vignettes/dendextend.html#introduction


# FDR cutoff.
MIN_FDR = 0.05

# Set the margins
MARGINS = c(10, 10)

# Relative heights of the rows in the plot.
LHEI = c(1, 5)

##Correlation plot
# generate correlation matrix of data 
data_cor <- cor(log2_norm)


# if names were numeric
# data_cor[ order(as.numeric(row.names(data_cor))), ]
hc <- data_cor %>%
# calculate a distance matrix using the euclidean method (standard),
   dist(method = "euclidean") %>%
# compute hierarchical clustering
   hclust(method = "average")

  dend <- hc %>%
    # turn that object into a dendrogram.
     as.dendrogram()

dend <- dend %>%
  # set("labels_colors", cutree(dend, k = 6)) %>%
   # set("branches_k_color", k = 6) %>%
   set("branches_lwd", c(0.5)) %>%
   ladderize



col <- colorRampPalette(c("white", "#333333")) (n=20)
groups <- data_cor %>% colnames %>%  str_detect("A")

side_col <- ifelse(groups == TRUE, "black", "white")
  
heatmap.2(data_cor,
          distfun =function(x) dist(x,method = 'euclidean'),
         # hclustfun=function(x) hclust(x,method = 'average'),
         Rowv = dend,
         Colv = dend,
         density.info="none",
         dendrogram="col",
         trace="none",
         scale="none",
         RowSideColors = side_col,
         ColSideColors = side_col,
         col = col)+
  scale_fill_grey()

```


<!-- ### Global heatmap -->

```{r global_heatmap, echo=FALSE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}
values <- log2_norm %>% 
  as.matrix() 

values = jitter(values, factor = 1, amount = 0.00001)

zscores = NULL
for (i in 1 : nrow(values)) {
  row = values[i,]
  zrow = (row - mean(row, na.rm = TRUE)) / sd(row, na.rm = TRUE)
  zscores = rbind(zscores, zrow)
}
 

# Set the row names on the zscores.
row.names(zscores) = row.names(values)

# Turn the data into a matrix for heatmap2.
zscores = as.matrix(zscores) 


# Set the color palette.
col <- colorRampPalette(c("red", "black", "green")) (n=20)


test <- zscores %>% colnames %>% str_detect("A")
# ifelse(test == TRUE, "yellow", "purple")

hc <- zscores %>%
# calculate a distance matrix using the euclidean method (standard),
   dist(method = "euclidean") %>%
# compute hierarchical clustering
   hclust()

  dend <- hc %>%
    # turn that object into a dendrogram.
     as.dendrogram()

dend <- dend %>%
  # set("labels_colors", cutree(dend, k = 6)) %>%
   set("branches_k_color", k = 8) %>%
   set("branches_lwd", c(0.5)) %>%
   ladderize



# # Generate heatmap
# heatmap_save <- heatmap.2(zscores,
#                           na.rm=TRUE,
#                           col=col,
#                           density.info="none",
#                           dendrogram="both",
#                           trace="none",
#                           ColSideColors=ifelse(test == TRUE, "purple", "yellow"),
#                           labRow=FALSE,
#                           margins=MARGINS,
#                           lhei=LHEI,
#                           Rowv = dend
# )



```
<!-- This global heatmap can be confusing. It gives much needed information about the samples clustering, but often times the volume of genes used may interfere with clustering of genes. This is a necessary QC step, but not necessary to understand the analysis.  -->

## Differential Expression of miRNA

### Question 1. Timepoint A vs B

Differences in miRNA pre- and post transplant

```{r ab_heatmap, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=10}

values <- DE_AB_dat %>% 
  dplyr::select(-47:-52)%>% 
  rownames_to_column("probe") %>% 
  # Removed the normalizing probes from the 0.05 or less list for the purposes of plotting
  filter(!(probe %in% c("GAPDH", "ACTB", "RPLP0", "LIG_POS_A", "LIG_POS_B", "LIG_POS_C"))) %>% 
  column_to_rownames("probe") %>% 
  as.matrix() 

values = jitter(values, factor = 1, amount = 0.00001)

zscores = NULL
for (i in 1 : nrow(values)) {
  row = values[i,]
  zrow = (row - mean(row, na.rm = TRUE)) / sd(row, na.rm = TRUE)
  zscores = rbind(zscores, zrow)
}


# Set the row names on the zscores.
row.names(zscores) = row.names(values)

# Turn the data into a matrix for heatmap2.
zscores = as.matrix(zscores) 


# Set the color palette.
# Pick Colors (Gray scale)
col <- colorRampPalette(c("white", "black")) (n=50)


test <- zscores %>% colnames %>% str_detect("B")
# ifelse(test == TRUE, "yellow", "purple")


# Generate heatmap
heatmap_save <- heatmap.2(zscores,
                          na.rm=TRUE,
                          col=col,
                          density.info="none",
                          dendrogram="both",
                          trace="none",
                          ColSideColors=ifelse(test == TRUE, "black", "white"),
                          # labRow=FALSE,
                          margins=MARGINS,
                          lhei=LHEI
)



```


### Question 2: Correlation of engraftment data 

Is there a miRNA profile that is associated with engraftment?
Using Rank correlation (spearman's) The following results identify miRNA targets associated with engraftment day



##### miRNAs from TimepointA significantly correlated with Engraftment variables
```{r engraftA, fig.height=9}

#### 1. Engraftment
nGenes = ncol(log2_normA);
nSamples = nrow(log2_normA);

# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.
moduleTraitCor = stats::cor(log2_normA, 
                            engraftment_vars, 
                            method = "spearman") # spearman: rank correlation 

## remove all the NAs
TraitCor_dropNA<- moduleTraitCor[rowSums(is.na(moduleTraitCor)) !=2,]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropNA)

# Calculate P-values based on sample size (package: WGCNA)
TraitPvalue = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold <- 0.05
# identify non significant genes according to threshold
notSignificant <- TraitPvalue %>%
  as.data.frame() %>% 
  filter(anc_engraftment_day >= pvalue_threshold & plt_engraftment_day >= pvalue_threshold) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSignificant),]
TraitPvalueFig <- TraitPvalue[!( rownames(TraitPvalue) %in% notSignificant),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(TraitPvalueFig, 1), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = names(engraftment_vars),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Engraftment Relationships"))

```
Timepoint A


<!-- ##### Correlated miRNAs by significance threshold -->
<!--  Using spearman's correlation, the following results were obtained.   -->
<!--  True = Significant (p<0.05) -->
<!-- ```{r engraftA_table} -->
<!-- library(kableExtra) -->

<!-- #### Useless function.. Just go with it.  -->
<!-- ## Logical, identifying significance at valuewritten in function. -->
<!-- sig_fun <- function(x){ -->
<!--   x <= (0.05) -->
<!-- } -->

<!-- # table of miRNAs that are significant -->
<!-- TraitPvalueFig %>% -->
<!--   as.data.frame() %>%  -->
<!--   mutate_all(sig_fun) %>%  -->
<!--   filter(anc_engraftment_day ==TRUE | plt_engraftment_day == TRUE) %>%  -->
<!--   kbl()%>% -->
<!--   kable_paper("hover", full_width = F) -->
<!-- ``` -->



### Question 3: Correlation of Immune reconstitution and clinical endpoints

 Are pre/post miRNA profiles associated with immune reconstitution (ALC, hemoglobin, platelets, neutrophils, monocytes) @ 6 months and 1yr?
 Treatment?
 
 

##### miRNAs from Timepoint A significantly correlated with Blood Cell Counts 6 months after Tx
###### Platelets and Alc
 These are the top significantly correlated miRNAs. Significance threshold for this figure is p = .05 <br> 
 
```{r bloodcellsA_6mo, fig.height=10}
library(Hmisc)

# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.

### Choose the right columns for blood cell counts
bloodcellcounts <- a_bVars %>% 
  dplyr::select(starts_with("neutrophil") ,
                            starts_with("alc"),
                            starts_with("monocyte"),
                            starts_with("platelet"),
                            starts_with("hemoglobin")) 

## Remove patients 35 and 2 because they received a second transplant
secondTxPts<- c("2", "35")
bloodcellcounts <- bloodcellcounts[!(row.names(bloodcellcounts) %in% secondTxPts),]


  


# Timepoint D. 1 year after transplant
y <- bloodcellcounts %>%
  dplyr::select(starts_with("alc"), starts_with("platelet")) %>% 
  dplyr::select(-ends_with("D")) %>% 
  drop_na() %>% 
  as.matrix()

## Filter log values by rownames of clinical traits
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

## test correlation between miRNA (log values) and clinical traits
bloodCellsCor <- stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 
# bloodCellsP <- moduleTraitCor$p[(ncol(y)+1):ncol(x), 1:ncol(y)] # Doesn't work

## remove rows with ALL NAs
TraitCor_dropNA<- bloodCellsCor[rowSums(is.na(bloodCellsCor)) !=2,]
# remove Controls
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
bloodCellsP = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold2 <- 0.05
#0.05/(ncol(x) * ncol(y))

notSig_fun2 <- function(x){
  x >= pvalue_threshold2
}


# identify non significant genes according to threshold
notSig <- bloodCellsP %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun2) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSig),]
bloodCellsPFig <- bloodCellsP[!( rownames(bloodCellsP) %in% notSig),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(bloodCellsPFig, 4), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)




# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = colnames(TraitCorFig),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Blood Cell Count Relationships"))


```
**Figure: Blood Cell Counts at 6mo check-up after Tx, correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`** <br>
<br>



###### Other Cell types at 6 months. 
```{r otherbloodcells6mo, fig.height=10}
# Timepoint D. 1 year after transplant
y <- bloodcellcounts %>%
  dplyr::select(-starts_with("alc"), -starts_with("platelet"),-ends_with("D")) %>% 
  drop_na() %>% 
  as.matrix()

## Filter log values by rownames of clinical traits
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

## test correlation between miRNA (log values) and clinical traits
bloodCellsCor <- stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 
# bloodCellsP <- moduleTraitCor$p[(ncol(y)+1):ncol(x), 1:ncol(y)] # Doesn't work

## remove rows with ALL NAs
TraitCor_dropNA<- bloodCellsCor[rowSums(is.na(bloodCellsCor)) !=3,]
# remove Controls
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
bloodCellsP = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold2 <- 0.05
#0.05/(ncol(x) * ncol(y))

notSig_fun2 <- function(x){
  x >= pvalue_threshold2
}


# identify non significant genes according to threshold
notSig <- bloodCellsP %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun2) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSig),]
bloodCellsPFig <- bloodCellsP[!( rownames(bloodCellsP) %in% notSig),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(bloodCellsPFig, 4), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = colnames(TraitCorFig),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Blood Cell Count Relationships"))

```
**Figure: Blood Cell Counts at six month check-up after Tx, correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold

```{r bloodCell_6mo_table}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= pvalue_threshold2
}

# table of miRNAs that are significant
bloodCellsPFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  relocate("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  # kbl()%>%
  # kable_paper("hover", full_width = F) %>% 
  DT::datatable()
```


##### miRNAs from Timepoint A significantly correlated with Blood Cell Counts 12 months after Tx
 These are the top significantly correlated miRNAs. Significance threshold for this figure is p = .05 <br> 
 
###### Platelets and ALC
```{r bloodcellsA_12mo, fig.height=10}



# Timepoint D. 1 year after transplant
y <- bloodcellcounts %>%
  dplyr::select(starts_with("alc"), starts_with("plat"), -ends_with("C"), ) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

bloodCellsCor <- stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 
# bloodCellsP <- moduleTraitCor$p[(ncol(y)+1):ncol(x), 1:ncol(y)] # Doesn't work

## remove rows with ALL NAs
TraitCor_dropNA<- bloodCellsCor[rowSums(is.na(bloodCellsCor)) !=2,]
# remove Controls
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
bloodCellsP = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold2 <- 0.05
#0.05/(ncol(x) * ncol(y))

notSig_fun2 <- function(x){
  x >= pvalue_threshold2
}


# identify non significant genes according to threshold
notSig <- bloodCellsP %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun2) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSig),]
bloodCellsPFig <- bloodCellsP[!( rownames(bloodCellsP) %in% notSig),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(bloodCellsPFig, 4), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = colnames(TraitCorFig),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Blood Cell Count Relationships"))

```
**Figure: Blood Cell Counts at one year check-up after Tx, correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**


###### Other Cell Types 
```{r bloodcellsA_12mo_other, fig.height=10}

# Timepoint D. 1 year after transplant
y <- bloodcellcounts %>%
  dplyr::select(-starts_with("alc"), -starts_with("plat"), -ends_with("C"), ) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

bloodCellsCor <- stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 
# bloodCellsP <- moduleTraitCor$p[(ncol(y)+1):ncol(x), 1:ncol(y)] # Doesn't work

## remove rows with ALL NAs
TraitCor_dropNA<- bloodCellsCor[rowSums(is.na(bloodCellsCor)) !=3,]
# remove Controls
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
bloodCellsP = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold2 <- 0.05
#0.05/(ncol(x) * ncol(y))

notSig_fun2 <- function(x){
  x >= pvalue_threshold2
}


# identify non significant genes according to threshold
notSig <- bloodCellsP %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun2) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSig),]
bloodCellsPFig <- bloodCellsP[!( rownames(bloodCellsP) %in% notSig),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(bloodCellsPFig, 4), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = colnames(TraitCorFig),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Blood Cell Count Relationships"))

```
**Figure: Blood Cell Counts at one year check-up after Tx, correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold
This is a table version of what is written above, if you'd like to look at cell types one by one, toggle the arrow next to the column name. :)Using spearman's rank correlation, the following results were obtained. A cut off threshold of 0.05 for at least one cell type.  
True = Significant (p<0.05)
```{r bloodCell_12mo_table}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= pvalue_threshold2
}

# table of miRNAs that are significant
bloodCellsPFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  relocate("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  
  # kbl()%>%
  # kable_paper("hover", full_width = F) %>% 
  DT::datatable()
```
 
### Question 4: Correlation of Clincal Scoring Endpoints

 Are miRNAs associated with frailty (3-5 = frail), cognition (MOCASocre 26+), fatigue (PROMISsCORE) and QoL (FACTBMTScore)? <br>
 Using spearman's rank correlation on the numeric values, the following results were obtained.
 

##### miRNAs from Timepoint A significantly correlated with MOCA
```{r clinA_moca, fig.height= 10}
### 1. Clinical Score Variables 


# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.

# Timepoint A. 1 year after transplant
y <- Clin_scoreVars %>% dplyr::select(starts_with("total_moca")) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

moduleTraitCor = stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 

## remove all the NAs
TraitCor_dropNA<- moduleTraitCor[rowSums(is.na(moduleTraitCor)) !=2,]
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
TraitPvalue = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold <- 0.05

#### Useless function.. Just go with it. 
## Logical, identifying significance at value written in function.
notSig_fun <- function(x){
  x >= pvalue_threshold
}

# identify non significant genes according to threshold
notSignificant <- TraitPvalue %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSignificant),]
TraitPvalueFig <- TraitPvalue[!( rownames(TraitPvalue) %in% notSignificant),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(TraitPvalueFig, 1), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = names(Clin_scoreVars %>% dplyr::select(starts_with("total_moca"))),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("MOCA Score Relationships"))

```
**Figure: Clinical Scores correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold
This is a table version of what is written above, if you'd like to look at scores one by one, toggle the arrow next to the column name. Using spearman's rank correlation, the following results were obtained. A cut off threshold of 0.05 for at least one cell type.  
True = Significant (p<0.05)
```{r clinScore_table_moca}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= (0.05)
}

# table of miRNAs that are significant
TraitPvalueFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  # kbl()%>%
  # kable_paper("hover", full_width = F) #%>%
  DT::datatable()
```


##### miRNAs from Timepoint A significantly correlated with PROMIS
```{r clinA_promis, fig.height= 10}
### 1. Clinical Score Variables 


# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.

# Timepoint A. 1 year after transplant
y <- Clin_scoreVars %>% dplyr::select(starts_with("promis")) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

moduleTraitCor = stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 

## remove all the NAs
TraitCor_dropNA<- moduleTraitCor[rowSums(is.na(moduleTraitCor)) !=2,]
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
TraitPvalue = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold <- 0.05

#### Useless function.. Just go with it. 
## Logical, identifying significance at value written in function.
notSig_fun <- function(x){
  x >= pvalue_threshold
}

# identify non significant genes according to threshold
notSignificant <- TraitPvalue %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSignificant),]
TraitPvalueFig <- TraitPvalue[!( rownames(TraitPvalue) %in% notSignificant),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(TraitPvalueFig, 1), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = names(Clin_scoreVars %>% dplyr::select(starts_with("promis"))),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Promis Score Relationships"))

```
**Figure: Clinical Scores correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold
This is a table version of what is written above, if you'd like to look at scores one by one, toggle the arrow next to the column name. Using spearman's rank correlation, the following results were obtained. A cut off threshold of 0.05 for at least one cell type.  
True = Significant (p<0.05)
```{r clinScore_table_promis}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= (0.05)
}

# table of miRNAs that are significant
TraitPvalueFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  # kbl()%>%
  # kable_paper("hover", full_width = F) #%>%
  DT::datatable()
```

##### miRNAs from Timepoint A significantly correlated with frailty
```{r clinA_frailty, fig.height= 10}
### 1. Clinical Score Variables 


# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.

# Timepoint A. 1 year after transplant
y <- Clin_scoreVars %>% dplyr::select(starts_with("frailty")) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

moduleTraitCor = stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 

## remove all the NAs
TraitCor_dropNA<- moduleTraitCor[rowSums(is.na(moduleTraitCor)) !=2,]
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
TraitPvalue = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold <- 0.05

#### Useless function.. Just go with it. 
## Logical, identifying significance at value written in function.
notSig_fun <- function(x){
  x >= pvalue_threshold
}

# identify non significant genes according to threshold
notSignificant <- TraitPvalue %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSignificant),]
TraitPvalueFig <- TraitPvalue[!( rownames(TraitPvalue) %in% notSignificant),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(TraitPvalueFig, 1), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = names(Clin_scoreVars %>% dplyr::select(starts_with("frailty"))),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Frailty Score Relationships"))
```
**Figure: Clinical Scores correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold
This is a table version of what is written above, if you'd like to look at scores one by one, toggle the arrow next to the column name. Using spearman's rank correlation, the following results were obtained. A cut off threshold of 0.05 for at least one cell type.  
True = Significant (p<0.05)
```{r clinScore_table_frailty}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= (0.05)
}

# table of miRNAs that are significant
TraitPvalueFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  # kbl()%>%
  # kable_paper("hover", full_width = F) #%>%
  DT::datatable()
```

##### miRNAs from Timepoint A significantly correlated with FACTBMT
```{r clinA_factbmt, fig.height= 10}
### 1. Clinical Score Variables 


# Spearman’s rank correlation coefficient, or Spearman’s correlation coefficient, as the name suggests, is a nonparametric approach to measuring correlation using rank values.

# Timepoint A. 1 year after transplant
y <- Clin_scoreVars %>% dplyr::select(starts_with("factbmt")) %>% 
  drop_na() %>% 
  as.matrix()

## Match rows to log values
x <- log2_normA[(row.names(log2_normA) %in% row.names(y)),]
x <- x %>% as.matrix()

moduleTraitCor = stats::cor(x, 
                            y, 
                            method = "spearman")# spearman: rank correlation 

## remove all the NAs
TraitCor_dropNA<- moduleTraitCor[rowSums(is.na(moduleTraitCor)) !=2,]
TraitCor_dropCtrls <- TraitCor_dropNA[!grepl("POS", rownames(TraitCor_dropNA)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("NEG", rownames(TraitCor_dropCtrls)),]
TraitCor_dropCtrls <- TraitCor_dropCtrls[!grepl("ACTB", rownames(TraitCor_dropCtrls)),]
TraitCor_dropNA_reorder <- cluster_matrix(TraitCor_dropCtrls)

# Calculate P-values based on sample size (package: WGCNA)
TraitPvalue = corPvalueStudent(TraitCor_dropNA_reorder, nSamples)

#### trim the insignificant genes to make the figure more readable 
pvalue_threshold <- 0.05

#### Useless function.. Just go with it. 
## Logical, identifying significance at value written in function.
notSig_fun <- function(x){
  x >= pvalue_threshold
}

# identify non significant genes according to threshold
notSignificant <- TraitPvalue %>%
  as.data.frame() %>% 
  filter_if(is.numeric, notSig_fun) %>% 
  row.names()
# remove genes from data sets
TraitCorFig <- TraitCor_dropNA_reorder[!( rownames(TraitCor_dropNA_reorder) %in% notSignificant),]
TraitPvalueFig <- TraitPvalue[!( rownames(TraitPvalue) %in% notSignificant),]

# TextMatrix will display correlations and their p-values
textMatrix =  paste(signif(TraitCorFig, 2), "\n(",
                    signif(TraitPvalueFig, 1), ")", sep = "");
dim(textMatrix) = dim(TraitCorFig)


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = TraitCorFig,
               xLabels = names(Clin_scoreVars %>% dplyr::select(starts_with("factbmt"))),
               yLabels = rownames(TraitCorFig),
               ySymbols = rownames(TraitCorFig),
               colorLabels = FALSE,
               colors = col,
               textMatrix = textMatrix,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Clinical Score Relationships"))

```
**Figure: Clinical Scores correlated with miRNAs at Timepoint A. Number of observations = `r dim(y)[[1]]`**

###### Correlated miRNAs by significance threshold
This is a table version of what is written above, if you'd like to look at scores one by one, toggle the arrow next to the column name. Using spearman's rank correlation, the following results were obtained. A cut off threshold of 0.05 for at least one cell type.  
True = Significant (p<0.05)
```{r clinScore_table_factbmt}
library(kableExtra)

### Useless function.. Just go with it.
# Logical, identifying significance at valuewritten in function.
sig_fun <- function(x){
  x <= (0.05)
}

# table of miRNAs that are significant
TraitPvalueFig %>%
  as.data.frame() %>%
  rownames_to_column("ID") %>% 
  group_by(ID) %>% 
  summarize_if(is.numeric, sig_fun) %>%
  # kbl()%>%
  # kable_paper("hover", full_width = F) #%>%
  DT::datatable()
```

```{r save_images}
library(ggplotify)
library(officer)
library(rvg)
library(patchwork)

PCA_comp <- PCA_before | PCA_after 


#### Powerpoint
PCA_comp_ppt <- dml(ggobj= PCA_comp)
point_graph_ppt <- dml(ggobj= point_graph_raw)
density_threshold_ppt <- dml(ggobj= density_threshold)
boxnorm_ppt <- dml(ggobj= boxnorm)



# doc <- read_pptx()
# 
# # QC   P L O T S
# doc <- add_slide(doc, 'Title and Content', 'Office Theme')
# doc <- ph_with(doc,
#                PCA_comp_ppt,
#                # res = 500,
#                location = ph_location(width = 9,
#                                       height = 6,
#                                               newlabel = ""))
# doc <- add_slide(doc, 'Title and Content', 'Office Theme')
# doc <- ph_with(doc,
#                point_graph_ppt,
#                # res = 500,
#                location = ph_location(width = 6,
#                                       height = 6,
#                                       newlabel = ""))
# doc <- add_slide(doc, 'Title and Content', 'Office Theme')
# doc <- ph_with(doc,
#                density_threshold_ppt,
#                # res = 500,
#                location = ph_location(width = 6,
#                                       height = 6,
#                                       newlabel = "")) 
# doc <- add_slide(doc, 'Title and Content', 'Office Theme')
# doc <- ph_with(doc,
#                boxnorm_ppt,
#                # res = 500,
#                location = ph_location(width = 8,
#                                       height = 6,
#                                       newlabel = "")) 
# 
# 
# out_dir <- "./threshold1_22/figures/"
# print(doc, target = str_c(out_dir,"all_ggplots.pptx"))

```